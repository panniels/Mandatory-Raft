This raft implementation is generated by Claude.ai, with the prompt “Can you make a implementation of raft election in Golang”.
a)	 Go-specific features (Like Goroutines, channels and so on)
There is only one goroutine in the program, that is used in main() called 
go cluster.runServer(id). The method initiates multiple servers and making them run concurrently.
The system does not use channels but instead relies on shared data with locks (sync.RWmutex). This ensures that when multiple servers run at the same time, only one of them can modify it at a time.
Furthermore the systems uses other go features like “time.Ticker” and “defer”. 
“time.Ticker” is used for repeatedly sending out signals at specific intervals. 
“Defer” is used for delaying an execution of a function until the rest of the function is finished.

b)	Communication method
The systems simulates Remote Procedure Calls with method calls like; server.RequestVote() and server.AppendEntries(). Furthermore, the system share different states in maps and slices, with mutex locks to ensure safe access when multiple goroutines interact with the same state.

c)	properties guaranteed by the protocol implementation (is it faithful to what we saw at the lecture?)

One of the properties that is guaranteed by the system is Election Safety. It does this by insuring that a candidate only can become a leader by getting majority votes. Furthermore, a server is only allowed to vote once pr term, by the variable (votedFor).
The system also guarantees that the leader uses Append-Only (with AppendEntries), and does not overwrite or delete entries.




